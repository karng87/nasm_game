\documentclass[a4paper]{moderncv}
\usepackage[scale=0.9]{geometry}
\usepackage{amsmath, kotex}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\moderncvtheme[blue]{classic}
\firstname{Functional}
\familyname{Programming}
\title{Haskell}
\address{Seoul, Korea}
\mobile{010-3201-xxxx}
\email{karng87@gmail.com}
\photo{logo.png}
\recipient{수령지}{Building 1st\\SongPaku\\Seoul\\Korea}
\opening{Haskell 에게}
\closing{안녕~}

\begin{document}
%\makelettertitle
%\blindtext
%\makeletterclosing
%\newpage

\maketitle

\section{Factor}
\cvitem{factor}{$factor\; :: Int \to [Int]$}
\cvitem{$factors\; x$}{$= [ n | n \gets [1..x], x \;`mod`\; n == 0]$}

\section{Sieve}
\cvitem{$\infty$}{lazy evaluation}

\cvitem{$sieve$}{$sieve\; :: [Int] \to [Int]$}
\cvitem{}{$sieve\; (p:xs) = p: sieve [x | x \gets xs, x \;`mod`\; p \neq 0]$}
\cvitem{sieve [2..10]}{error but sieve $[2..] \to \infty$ is no error with $\infty$}
\cvitem{take 10 sieve \$ [2..]}{good}


\section{Generator}
\cvitem{generator}{$x \gets xs $}
\cvlistitem{x for in xs}
\cvitem{multiple generators}{$[\;(x,y) | x \gets [1..5], y \gets [4,5]\;]$}
\cvlistitem{separated by comma, like nested loops}
\cvitem{}{$[\;(x,y) | y \gets [4,5], x \gets [1,2,3]\;] \iff [\;(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)\;]$}

\section{Guard}
\cvitem{$\mid\quad$}{if ... then ...}
\cvitem{$\mid$ x==y =True}{if x==y then True}

\section{List Comprehension}
\cvitem{$[\;x\mid ...]$}{such that $x \in ...$}

\section{Higher order function}
\cvitem{a function}{is called higher-order,}
\cvitem{}{if it takes a function as an argument or return a function as a result.}
\cvlistitem{${twice}\; :: (a \to a) \to a \to a \quad {twice}\; f\; x\; = f\; (\;f \; x\;)$}
\cvlistitem{${map}\; :: (a \to b) \to [a] \to [b]$}
\cvlistitem{${filter}\; :: (a \to Bool) \to [a] \to [a]$}
\cvlistitem{${foldr}\; :: (a \to b \to b) \to b \to [a] \to b$}

\section{Quick Sorting}
\cvitem{$qsort$}{$::\; Ord\; a \implies [a] \to [a]$}
\cvitem{$qsort\; [\;]$}{$=\; [\;]$}
\cvitem{$qsort\; (x:xs)$}{$=\; qsort\; ys\; ++\; [x]\; ++\; qsort\; zs$}
\cvitem{where}{$\qquad ys = [ x' | x' \gets xs, x' < x$}
\cvitem{}{$\qquad zs = [ x' | x' \gets xs, x' > x$}

\section{Merge Sorting}
\cvitem{$merge$}{$::\; [a] \to [a] \to [a]$}
\cvitem{$merge$}{$[\;]\; ys\; = \;[ys]$}
\cvitem{$merge$}{$xs\; [\;]\; =\;[xs]$}
\cvitem{$merge$}{$(x:xs)\; (y:ys)$}
\cvitem{}{$| x \leq y = x:\; merge\; xs\; (y:ys)$}
\cvitem{}{$| x < y = y:\; merge\; (x:xs)\; ys$}

\cvitem{$msort$}{$::\; Ord\; a \implies [a] \to [a]$}
\cvitem{$msort$}{$[\;]\; = \; [\;]$}
\cvitem{$msort$}{$[x]\; = \; [x]$}
\cvitem{$msort$}{${xs}\; =\; {merge}\; ({msort}\; ys)\; ({msort}\; zs)$}
\cvitem{where}{$\qquad {hl}\; =\;{div}\; ({length}\; xs) 2$}
\cvitem{}{$\qquad {ys}\; =\; {take}\; {hl}\; xs$}
\cvitem{}{$\qquad {ys}\; =\; {drop}\; {hl}\; xs$}

\section{type}
\cvlistitem{how one introduces an alias for an algebraic data type into Haskell}
\cvitem{type TypeSymbol}{= Type Constructor(using Built in type values)}
\cvlistitem{type declaration $\cong$ type Symbol} 
\cvitem{type declaration}{a new name for an existing type can be defined usging a type declaration.}
\cvitem{}{can be used to make other types easier to read.}
\cvlistitem{type parameter}
\cvitem{type parameter}{Like function definitions, type declarations can also have parameters.}
\cvitem{}{type Pair a = (a,a)}
\cvitem{a}{is a type parameter}
\cvitem{}{mult :: Pair Int $\to$ Int}
\cvitem{Int}{is a type argument of Pair a}
\cvitem{}{mult (m,n) = n*n}
\cvlistitem{can be nested:}
\cvitem{nested}{type Pos = (Int, Int)}
\cvitem{}{type Trans = Pos $\to$ Pos}
\cvlistitem{type define}
\cvitem{define}{origin :: Pos}
\cvitem{}{origin = (0,0)}
\cvitem{define}{left :: Pos $\to$ Pos}
\cvitem{}{left (x,y) = (x-1, y)}

\cvlistitem{can not be recursive:}
\cvitem{!!wrong}{type Tree = (Int, [Tree])}

\section{data $\iff$ new type}
\cvlistitem{how one introduces new algebraic data type into Haskell}
\cvitem{data DataSymbol}{= Data Constructor(using New type values)}
\cvlistitem{data declaration $\cong$ data Symbols}
\cvitem{data declaration}{A completely new type can be defined by specifying its values using a data declaration.}
\cvitem{data Symbol}{can also have parameters}
\cvitem{data Maybe a}{Nothing | Just a}
\cvitem{}{data Typename = new type values}
\cvitem{data Bool}{= False | True}
\cvitem{Bool}{is a new type, with two new values False and True.}
\cvlistitem{Data Constructor}
\cvitem{Data Constructor}{can also have parameters}
\cvitem{data Shape}{= Circle Float | Rect Float Float}
\cvitem{True, False}{is a data constructors for the type Bool.}
\cvitem{Type and constructor names}{must always begin with an upper-case letter.}
\cvlistitem{can be recursive:}
\cvitem{data Nat}{Zero | Succ Nat}
\cvitem{}{Nat is a new type}
\cvitem{}{Zero :: Nat}
\cvitem{}{Succ :: Nat -> Nat }
\cvitem{}{Succ (Succ (Succ Zero))}
\cvitem{Nat-ural number}{$\iff$ 1 + (1 +  (1 +  0)) = 3}
\cvitem{}{nat2int :: Nat $\to$ Int}
\cvitem{}{nat2int Zero = 0}
\cvitem{nat2int (Succ n)}{1+ nat2int (n-1)}
\cvitem{int2nat}{:: Int $\to$ Nat}
\cvitem{int2nat 0}{= Zero}
\cvitem{int2nat n}{= Succ (int2nat (n-1))}
\cvitem{add}{:: Nat $\to$ Nat $\to$ Nat}
\cvitem{add Zero n}{= n}
\cvitem{add (Succ m) n}{= Succ (add m n)}

\section{::}
\cvitem{kind}{$* \to *$}

\section{Terms}
\cvlistitem{https://wiki.haskell.org/Keywords}
\cvitem{::}{Read as ``has type"}
\cvitem{;}{Statement separator}
\cvitem{,}{Separator in lists, tuples, records.}
\cvitem{=}{Used in definitions}
\cvitem{=>}{Used to indicate instance contexts.}
\cvitem{kind}{In type theory, a kind is the type of a type constructor,}
\cvitem{}{or the type of a higher-order type operator.}
\cvitem{}{* $\iff$ the kind of any data type - called type.}
\cvitem{\_}{wild card}
\cvitem{infix function}{x + y}
\cvitem{}{to prefix $\iff$ (+) x  y}
\cvitem{prefix function}{add x y}
\cvitem{}{to infix $\iff$ x \`{}add\`{} y}

\cvitem{Perfect number}{a positive integer is perfect if it equals the sum of all of its factors, excluding the number itself}
\cvitem{induction}{귀납, 유도}
\cvitem{congruence}{합동}
\cvitem{conjugate}{켤레}
\cvitem{Terminal}{grammer에 종속되는 symbol}
\cvitem{Token}{= Terminal symbol}
\cvitem{Nonterminal}{grammer에 독립적인 symbol}
\cvitem{Start Symbol}{Nonterminal symbol로 시작해야 한다.}

\end{document}

