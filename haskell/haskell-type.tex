\documentclass[a4paper]{moderncv}
\usepackage[scale=0.9]{geometry}
\usepackage{amsmath, kotex}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\moderncvtheme[blue]{classic}
\firstname{Type}
\familyname{Haskell}
\title{functional progrmming}
\address{Seoul, Korea}
\mobile{010-3201-xxxx}
\email{karng87@gmail.com}
\photo{logo.png}
\recipient{수령지}{Building Type\\SongPaku\\Seoul\\Korea}
\opening{Type 에게}
\closing{안녕~}

\begin{document}
%\makelettertitle
%\blindtext
%\makeletterclosing
%\newpage

\maketitle

\section{Prerequisite}
\cventry{}{Obj(C)}{obj of Category}{}{}{}
\cventry{}{Object}{set 이 될수 있는것}{}{}{}
\cventry{}{Hom(C)}{homophism of Category}{}{}{}
\cventry{}{MOrphism}{map arrow}{}{}{}
\cventry{}{C(a,b)}{all mophism a to b in Category}{}{}{}
\cventry{}{Category}{sets}{}{}{}
\cventry{}{Monoid}{single object}{}{}{}
\cventry{one object}{Monoid}{mempty}{monoid empty}{:: a}{}
\cventry{}{Monoid}{mappend}{monoid append}{:: a $/to$ (a $/to$ a)}{return new function}
\cventry{between C}{isomorphism}{linking category}{f $\circ$ g $\equiv$ h}{f' $\circ$ g' $\equiv$ h'}{}
\cventry{between C}{class Functor f :: $\to$ * where}{}{}{}{}
\cventry{Functor}{fmap :: (a $\to$ b) $\to$ (f a $\to$ f b)}{다른 집합에 사용 가능한 함수를 만들어 준다}{}{}{}
\cventry{Functor}{fmap :: (a $\to$ b) $\to$ f a $\to$ f b}{함수를 다른 집합에 쏘아주는것이다}{that only takes a single unary function and lifts it into the functorial context}{}{}
\cventry{Functor}{(<\$) :: a $\to$ f b $\to$ f a b}{}{}{}{}
\cventry{Monoidal}{Monoidal Functors}{$\equiv$tensor category}{with a bifunctor}{(,)}{}
\cventry{Monoidal}{class Funtor f $\Rightarrow$ Monoidal f where}{:with a bifunctor}{(,)}{}{}
\cventry{Monoidal}{unit :: f()}{:with a bifunctor}{(,)}{}{}
\cventry{Monoidal}{(**) :: f a $\to$ f b $\to$ f (a,b)}{:with a bifunctor}{(,)}{}{}
\cventry{Monoidal}{instanc Monoidal [] where}{:with a bifunctor}{(,)}{}{}
\cventry{Monoidal}{unit = [()]}{:with a bifunctor}{(,)}{}{}
\cventry{Monoidal}{(**) as bs = [(a,b) | a $\gets$ as, b $\gets$ bs]}{:with a bifunctor}{(,)}{}{}
\cventry{}{map f (map g)}{map (f $\circ$ g}{}{}{}
\cventry{Type}{이미 정해진 규격을 만들어 놓고 그 중에서 하나만 선택하게 만들어야 할때}{}{}{}{}
\cventry{Constructor}{= Cardinality: 규격중 선택 할 수 있는 목록을 제시하는 것}{}{}{}{}

\cventry{Class}{이미 정해진 규격 대로 행동 해야 하는 것들만 모아 놓은 집합으로 그 규격(protocol,청사진)을 제시하는 것}{}{}{}{}
\cventry{Instance}{Class에 속하는 원소나 집합이 구체적으로 자기 실정에 맞게 구현하는것}{}{}{}{}

\section{Type}
\cvlistitem{Type $\cong$ Set}
\cventry{name}{type 이름 parameters = constructor parameters $\mid$ and so on}{타입이름}{}{}{}
\cventry{constructors}{type name parameters = 생성자 parameters $\mid$ and so on}{생성자}{}{}{}
\cventry{parameters}{type name 파라미터 = constructor parameters $\mid$ and so on}{파라미터}{}{}{}

\section{type}
\cvitem{}{type Name parameters = Constructor parameters ...}
\cvitem{}{data Name parameters = Constructor parameters ...}

\cvitem{type}{type ReadS a = String -> [(a,String)]}
\cvitem{data}{data Set a = NilSet | ConsSet a(Set a)}
\cvlistitem{types are how you describe the data your program will work with.}

\subsection{<< Type syntax >>}
\cvitem{Capital Letter}{Id, Constructors }
\cvitem{keyword}{type, data}
\cvitem{Id}{tpye name, type identifire}
\cvitem{parameters}{$\forall a \in $ an arbitary Type}
\cvitem{}{constrain the category}
\cvitem{Values}{$\cong$ the type Id of elements}

\subsection{<< Type\_Name parameters = Type\_Constructor parameters $\mid$ ... >>}
\cvitem{type}{기존(built in) 타입(집합)의 원소만을 이용하여 새로운 타입(집합)을  정의한다.}

\section {data}
\cvlistitem{완전히 새로운 원소를 정의하여 새로운 타입(집합)을 정의한다.}
\subsection{<< data Id parameters = TypeConstructor Id parameters $\mid$ ... >>}
\cvitem{$data [contex \implies]$}{$
  \underbrace{type}_{name}\; 
  \underbrace{tv_1 \cdots tv_i}_{parameters} 
  = \underbrace{cons_1}_{constructor} \; 
  \underbrace{cons_1^{p_1} \cdots cons_1^{p_n}}_{consructor\; parameter} 
  \mid \cdots \mid con_m \; c_mt_1 \cdots c_mt_q \; 
  [deriving]$}

\section{Category}
\cvitem{category $\cong$ class}{공통적인 성질을 가진 것들을 모아놓은것}

\section{class}
\cventry{Class}{이미 정해진 규격 대로 행동 해야 하는 것들만 모아 놓은 집합}{}{}{}{}
\cvitem{}{isomorphism}

\section{instance}
\cvitem{instance}{실제로 통합시켜야 하는 구체적인 타입을 모아놓고 구현하는 개념}


\cvitem{[contex $\implies$]}{optional context}

\section{kind}
\cvitem{kind}{how many the type have parameters}
\cvitem{}{In type theory, a kind is the type of a type constructor,}
\cvitem{}{$* \to * \to *$}

\section{Function}
\cvlistitem{the only thing a function can do in Haskell}
\cvlistitem{is give us back some result basesd on the parameters we gave it.}
\cventry{function of}{Category}{apply the difference category sets}{}{}{}
\cventry{function of}{Expression}{apply the difference category sets}{}{}{}

\subsection{<< first class function >>}
\cvlistitem{$\equiv$ Paremeter, Return, Variable}

\subsection{<< pure function >>}
\cvlistitem{laziness, robustness, modularity}
\cventry{pure function}{pure function}{functions with same input give same output}{}{}{}
\cventry{}{Time Invariant}{Functions with same input give same output}{}{}{}
\cventry{}{Lasiness}{Nothing gets evaluated until it has to be}{time invariant}{}{}
\cventry{pure}{bind}{let $\sim$ in $\sim$}{}{}{}
\cvlistitem{4 * \(let a = 9 in a+1\) + 2}
\cventry{let $\sim$ in $\sim$}{let binding in expression}{where}{bindings are names to be given to expressions}{and expression is to be evaluated}{}
\cventry{list comprehension}{the IN part isn't needed}{}{}{}{}

\subsection{<< impure >>}
\cvlistitem{side effect}
\cvitem{side effect}{when a function changes state, we say that the function has side-effects}
\cvitem{}{usually either reading from the input or printing stuff to the screen}

\cvlistitem{IO Action}
\cvitem{IO action}{will carry out an action with a side effect}
\cvitem{}{also contain some kind of return value inside it}
\cvitem{IO ()}{Doesn't really have any kind of meaningful return value}
\cvlistitem{when will an IO action be performed?}
\cvitem{main}{An IO action will be performed when we give it a name of main and then run our program.}
\cventry{main}{main :: IO something}{where}{something is some concrete type.}{}{}
\cventry{[IO a]}{sequence}{[IO a] $\to$ IO a,IO a ...}{}{}{}

\subsection{<< bind >>}
\cvlistitem{$\gets$ :in impure}
\cventry{in do block}{$\gets$}{to get the value out of an I/O action}{you have to perform it inside another I/O action by binding it to a name with $\gets$}{}{}
\cvlistitem{where :in pure}
\cventry{where}{patern match}{where (skinny,normal,fat) = (18.5, 25.0, 30.0)}{}{}{}
\cventry{where}{func firsN lastN = [f] ++ ". " ++ [l] ++ "." }{}{}{}{}
\cventry{}{$\qquad$ where (f:\_)=firstN}{}{}{}{}
\cventry{}{$\qquad$ $\qquad$ $\:$ (l:\_)=lastN}{}{}{}{}
\cventry{where}{where bmi w h = w / h \^{}2}{we can define constants and functons in where block}{}{}{}

\subsection{<< do block >>}
\cventry{do block}{to blue together two I/O actions into one}{}{}{}{}
\cvlistitem{$\gets$}
\cvlistitem{let}
\cvlistitem{where}
\cvlistitem{if $\sim$ then I/O action else I/O action}
\cvlistitem{if $\sim$ then return() else do main}
\cvlistitem{return ()}

\section{parameter, argument}
\cvitem{parameter}{부속 건물- 재료를 제공해주는 역할}
\cvitem{argument}{실제 사용되는 곳에서 parameter가 구체적으로 확정 되는 경우}

\section{Operator}
\cvlistitem{https://wiki.haskell.org/Keywords}
\cvitem{=}{Used in definitions}
\cvitem{()}{Unit, empty tuple}
\cvlistitem{putStrLn :: String $\to$ IO ()}
\cvitem{()}{is dummy value: Printing a string to the terminal doesn't really have any kind of meaningful return value}

\cvitem{::}{Read as ``has type"}
\cvitem{;}{Statement separator}
\cvitem{,}{Separator in lists, tuples, records.}
\cvitem{=>}{Used to indicate instance contexts.}
\cvitem{}{or the type of a higher-order type operator.}
\cvitem{}{* $\iff$ the kind of any data type - called type.}
\cvitem{\_}{wild card}
\cvitem{infix function}{x + y}
\cvitem{}{to prefix $\iff$ (+) x  y}
\cvitem{prefix function}{add x y}
\cvitem{}{to infix $\iff$ x \`{}add\`{} y}

\section{syntax}
\cventry{where}{where}{bindings are a syntactic construct that let you bind to variables at the end of a function}{and}{the whole function can see them}{including all the guards}
\cventry{let}{let}{you bind to variables anywhere}{and, are expressions themselves}{but are very local}{so they don't span across guards}
\section{Math Terms}
\cvitem{Perfect number}{a positive integer is perfect if it equals the sum of all of its factors, excluding the number itself}
\cvitem{Isomorphic}{with the same cardinality, same structure wrt a function}
\cvitem{Curry Howard}{represents an isomorphism between `() $\to$' a and a}
\cvitem{ihabitant}{원소,주민}
\cvitem{cardinality}{the sum of inhabitants}
\cvitem{induction}{귀납, 유도}
\cvitem{congruence}{합동}
\cvitem{conjugate}{켤레}

\section{Language Terms}
\cvitem{Terminal}{grammer에 종속되는 symbol}
\cvitem{Token}{= Terminal symbol}
\cvitem{Nonterminal}{grammer에 독립적인 symbol}
\cvitem{Start Symbol}{Nonterminal symbol로 시작해야 한다.}
\cventry{unless}{if not}{}{}{}{}

\end{document}

